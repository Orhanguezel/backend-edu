## **2. Wie wird `Errors` allgemein behandelt?**  
**(Genel olarak hatalar nasÄ±l ele alÄ±nÄ±r?)**  

Hatalar (`Errors`), **Mongoose ve Express.js iÃ§inde** farklÄ± yÃ¶ntemlerle iÅŸlenebilir. **Hata yÃ¶netimi**, uygulamanÄ±n **daha saÄŸlam, gÃ¼venli ve kullanÄ±cÄ± dostu olmasÄ±nÄ± saÄŸlar**.  

### **ğŸ“Œ 2.1. Hata TÃ¼rleri (Fehlertypen)**
Mongoose ve Node.js iÃ§inde **farklÄ± hata tÃ¼rleriyle** karÅŸÄ±laÅŸabiliriz:

| **Hata TÃ¼rÃ¼**       | **AÃ§Ä±klama** | **Ã–rnek** |
|-----------------|------------------|-----------|
| **`ValidationError`** | Veri doÄŸrulama hatalarÄ±. | `firstName` en az 3 karakter olmalÄ±dÄ±r. |
| **`CastError`** | GeÃ§ersiz ObjectId kullanÄ±mÄ±. | `_id` alanÄ± yanlÄ±ÅŸ formatta. |
| **`MongoServerError`** | MongoDB ile ilgili hatalar. | AynÄ± `email` ile kayÄ±t yapÄ±lamaz. |
| **`ReferenceError`** | TanÄ±mlanmamÄ±ÅŸ deÄŸiÅŸken hatasÄ±. | `user` deÄŸiÅŸkeni tanÄ±mlanmamÄ±ÅŸ. |
| **`SyntaxError`** | JSON veya kod hatalarÄ±. | JSON yapÄ±sÄ± hatalÄ±. |

---

## **ğŸ“Œ 2.2. `try-catch` ile Hata YÃ¶netimi**
**HatalarÄ± yakalamak iÃ§in `try-catch` bloÄŸu kullanÄ±lÄ±r.**  
Bu, **senkron (`sync`) ve asenkron (`async`) kodlarda** iÅŸe yarar.

### **Ã–rnek: KullanÄ±cÄ± Kaydetme (`POST /users`)**
```js
const addUser = async (req, res) => {
  try {
    const newUser = new User(req.body);
    await newUser.save();
    res.json({ msg: "Benutzer erfolgreich hinzugefÃ¼gt!", newUser });
  } catch (error) {
    console.error("Fehler:", error);

    if (error.name === "ValidationError") {
      return res.status(400).json({ msg: "Validierungsfehler!", errors: error.errors });
    }

    res.status(500).json({ msg: "Interner Serverfehler!", error });
  }
};
```
âœ… **Bu sayede:**  
âœ” **DoÄŸrulama hatalarÄ± (`ValidationError`) iÃ§in Ã¶zel mesajlar dÃ¶nebiliriz.**  
âœ” **DiÄŸer hatalar iÃ§in `500 - Internal Server Error` dÃ¶ndÃ¼rebiliriz.**

---

## **ğŸ“Œ 2.3. `asyncHandler` ile Daha Temiz Kod**
Her `try-catch` bloÄŸu yazmak yerine, **hata yÃ¶netimini merkezi hale getiren bir fonksiyon** kullanabiliriz.

### **Ã–rnek: `asyncHandler` ile Daha Temiz API**
```js
import asyncHandler from "express-async-handler";

const addUser = asyncHandler(async (req, res) => {
  const newUser = new User(req.body);
  await newUser.save();
  res.json({ msg: "Benutzer erfolgreich hinzugefÃ¼gt!", newUser });
});
```
âœ… **Burada:**  
- **`express-async-handler` kÃ¼tÃ¼phanesi**, `try-catch` bloÄŸunu otomatik olarak yÃ¶netir.  
- **Kod daha okunaklÄ± hale gelir.**  

---

## **ğŸ“Œ 2.4. Merkezi Hata YÃ¶netimi (Global Error Handling)**
EÄŸer **tÃ¼m hatalarÄ± merkezi bir yerden yÃ¶netmek istiyorsak**, **Express.jsâ€™te bir hata yakalayÄ±cÄ± (`error handler`) middleware oluÅŸturabiliriz.**  

### **Ã–rnek: Hata YÃ¶netim Middleware (`errorMiddleware.js`)**
```js
const errorHandler = (err, req, res, next) => {
  console.error("Fehler:", err);

  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message || "Interner Serverfehler!";

  if (err.name === "ValidationError") {
    statusCode = 400;
    message = "Validierungsfehler!";
  }

  res.status(statusCode).json({
    msg: message,
    error: err.errors || {}
  });
};

export default errorHandler;
```
### **ğŸ“Œ Express.js'de KullanÄ±mÄ± (`server.js`)**
```js
import express from "express";
import errorHandler from "./middlewares/errorMiddleware.js";

const app = express();
app.use(express.json());

// ğŸ”¹ Hata yÃ¶netimini sona ekliyoruz
app.use(errorHandler);
```
âœ… **BÃ¶ylece tÃ¼m API hatalarÄ± otomatik olarak yÃ¶netilir!** ğŸš€  

---

## **ğŸ“Œ 2.5. Ã–zel Hata Tipleri ile Daha Ä°yi Hata YÃ¶netimi**
Expressâ€™te **Ã¶zel hata sÄ±nÄ±flarÄ± (`Custom Error Classes`)** oluÅŸturarak, **daha anlamlÄ± hata mesajlarÄ±** dÃ¶ndÃ¼rebiliriz.

### **Ã–rnek: `AppError` SÄ±nÄ±fÄ± ile Ã–zel Hata TanÄ±mlama**
```js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}

const errorHandler = (err, req, res, next) => {
  console.error("Fehler:", err);

  const statusCode = err.statusCode || 500;
  res.status(statusCode).json({ msg: err.message });
};
```
Bu ÅŸekilde **`new AppError("KullanÄ±cÄ± bulunamadÄ±!", 404)`** ÅŸeklinde hata dÃ¶ndÃ¼rebiliriz.

---

## **ğŸ“Œ 2.6. `404` SayfalarÄ± iÃ§in Middleware**
EÄŸer **geÃ§ersiz bir rota Ã§aÄŸrÄ±lÄ±rsa (`404 - Not Found`)**, bunu Ã¶zel bir middleware ile yÃ¶netebiliriz.

### **Ã–rnek: `notFoundMiddleware.js`**
```js
const notFound = (req, res, next) => {
  res.status(404).json({ msg: "Route nicht gefunden!" });
};

export default notFound;
```
Ve bunu **`server.js` iÃ§inde kullanabiliriz:**
```js
import notFound from "./middlewares/notFoundMiddleware.js";
app.use(notFound);
```
âœ… **BÃ¶ylece geÃ§ersiz rotalar iÃ§in Ã¶zel bir `404` mesajÄ± dÃ¶ner!** ğŸš€

---

## **ğŸ“Œ 2.7. MongoDB Ã–zel Hata TÃ¼rleri**
MongoDB iÅŸlemlerinde en sÄ±k karÅŸÄ±laÅŸÄ±lan **Ã¶zel hata tÃ¼rleri ÅŸunlardÄ±r:**

### **1. `CastError` (GeÃ§ersiz `ObjectId` KullanÄ±mÄ±)**
- EÄŸer geÃ§ersiz bir `ObjectId` ile arama yapÄ±lÄ±rsa (`findById()`), `CastError` hatasÄ± oluÅŸur.
  
**Ã–rnek:**
```js
const getUser = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) throw new AppError("Benutzer nicht gefunden!", 404);

    res.json(user);
  } catch (error) {
    if (error.name === "CastError") {
      return res.status(400).json({ msg: "UngÃ¼ltige ID!" });
    }
    res.status(500).json({ error });
  }
};
```
âœ… **YanlÄ±ÅŸ `id` girildiÄŸinde `"UngÃ¼ltige ID!"` mesajÄ± dÃ¶ner.**

---

### **2. `MongoServerError` (Duplicate Key HatasÄ±)**
MongoDB'de **benzersiz (`unique`)** olan bir alan **tekrar eklenirse**, **`E11000 duplicate key error`** hatasÄ± oluÅŸur.

**Ã–rnek:**
```js
if (error.code === 11000) {
  return res.status(400).json({ msg: "Diese E-Mail ist bereits registriert!" });
}
```
âœ… **Bu, eÄŸer e-posta adresi tekrar eklenmeye Ã§alÄ±ÅŸÄ±lÄ±rsa hata dÃ¶ndÃ¼rÃ¼r.** ğŸš€  

---

## **ğŸ“Œ 2.8. SonuÃ§**
ğŸ¯ **Genel hata yÃ¶netimi ile:**  
âœ” **HatalarÄ± `try-catch` ve `asyncHandler` ile yÃ¶netebiliriz.**  
âœ” **Merkezi hata middlewareâ€™i (`errorHandler`) kullanarak daha dÃ¼zenli bir yapÄ± oluÅŸturabiliriz.**  
âœ” **MongoDBâ€™ye Ã¶zel hatalarÄ± (`CastError`, `Duplicate Key`) Ã¶zel olarak ele alabiliriz.**  
âœ” **Daha iyi hata mesajlarÄ± ile kullanÄ±cÄ± deneyimini artÄ±rabiliriz.** ğŸš€  

ğŸš€ **Sonraki adÄ±m: `Soft Delete` vs. `Hard Delete`** ğŸ’ª