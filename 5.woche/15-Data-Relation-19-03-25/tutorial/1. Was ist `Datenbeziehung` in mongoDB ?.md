### **1. Was ist `Datenbeziehung` in MongoDB? (MongoDB'de Veri Ä°liÅŸkisi Nedir?)**  

MongoDB, **NoSQL (DokÃ¼man TabanlÄ±) bir veritabanÄ±** olduÄŸu iÃ§in iliÅŸkisel veritabanlarÄ±ndan (SQL) farklÄ± bir veri saklama yapÄ±sÄ±na sahiptir. Ancak, uygulamalarda veriler arasÄ±ndaki iliÅŸkileri kurmak ve verimli sorgular yapmak iÃ§in **Datenbeziehung (veri iliÅŸkileri)** kullanÄ±lÄ±r.

MongoDBâ€™de veri iliÅŸkileri, **bir dokÃ¼manÄ±n baÅŸka bir dokÃ¼man ile baÄŸlantÄ±sÄ±nÄ± nasÄ±l kuracaÄŸÄ±nÄ± ve yÃ¶neteceÄŸini belirler**. Geleneksel iliÅŸkisel veritabanlarÄ±nda **foreign key (yabancÄ± anahtar)** ile yapÄ±lan iÅŸlemler, MongoDBâ€™de **referanslar (refs) ve iÃ§ iÃ§e geÃ§miÅŸ dokÃ¼manlar (embedded documents)** ile saÄŸlanÄ±r.

---

### **ğŸ“Œ MongoDB'de Veri Ä°liÅŸkilerinin Ã–nemi**
MongoDBâ€™de veri iliÅŸkileri kullanarak:
âœ” **Veri tutarlÄ±lÄ±ÄŸÄ±** saÄŸlanÄ±r.  
âœ” **Tekrar eden veri (redundancy)** miktarÄ± azaltÄ±lÄ±r.  
âœ” **Sorgular daha hÄ±zlÄ± ve optimize Ã§alÄ±ÅŸÄ±r**.  
âœ” **Veri baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¶netilebilir** hale gelir.  

---

## **ğŸ“Œ MongoDB'de Veri Ä°liÅŸkileri NasÄ±l Ã‡alÄ±ÅŸÄ±r?**
MongoDB'de veri iliÅŸkileri **iki ana yÃ¶ntemle** oluÅŸturulur:

1. **Embedded Documents (Ä°Ã§ Ä°Ã§e GeÃ§miÅŸ DokÃ¼manlar - Ä°Ã§ Ä°Ã§e Ä°liÅŸki)**  
   - **Ä°lgili veriler aynÄ± koleksiyonda (collection) tek bir dokÃ¼man iÃ§inde saklanÄ±r**.  
   - **HÄ±zlÄ± okuma** gerektiren senaryolarda tercih edilir.  
   - **Ã–rnek:** KullanÄ±cÄ± (User) verisi iÃ§inde doÄŸrudan adres bilgilerini saklamak.

2. **Reference (Referans ile Ä°liÅŸkilendirme - AyrÄ±k Ä°liÅŸki)**  
   - **Ä°lgili veriler farklÄ± koleksiyonlarda saklanÄ±r ve ObjectId ile birbirine baÄŸlanÄ±r**.  
   - **Daha az veri tekrarÄ± (redundancy)** saÄŸlar.  
   - **Ã–rnek:** Bir kullanÄ±cÄ± (User) ile sipariÅŸleri (Orders) farklÄ± koleksiyonlarda saklamak.

---

## **ğŸ“Œ Embedded Documents (Ä°Ã§ Ä°Ã§e GeÃ§miÅŸ DokÃ¼manlar)**
**Bu yÃ¶ntemde, iliÅŸkili veriler doÄŸrudan ana dokÃ¼manÄ±n iÃ§ine gÃ¶mÃ¼lÃ¼r.**  
Ã–rneÄŸin, bir kullanÄ±cÄ±nÄ±n **adres bilgilerini iÃ§eren bir User modeli** ÅŸu ÅŸekilde olabilir:

```json
{
  "_id": "603d9c69f1a5c34b8c4f9e4a",
  "name": "Orhan GÃ¼zel",
  "email": "orhan@gmail.com",
  "address": {
    "street": "Berliner StraÃŸe 10",
    "city": "Berlin",
    "zip": "10115"
  }
}
```
**âœ” AvantajlarÄ±:**  
- **HÄ±zlÄ± eriÅŸim saÄŸlar** (Okuma iÅŸlemleri iÃ§in performanslÄ±dÄ±r).  
- **Tek sorgu ile tÃ¼m verilere ulaÅŸÄ±labilir**.  
- **Ä°lgili veriler birbirine baÄŸÄ±mlÄ±ysa (Ã¶rneÄŸin adres bilgileri sÄ±k deÄŸiÅŸmezse) uygundur**.  

**âŒ DezavantajlarÄ±:**  
- **BÃ¼yÃ¼k veri iÃ§eren iliÅŸkilerde esneklik kaybÄ± yaÅŸanabilir**.  
- **GÃ¼ncellemelerde performans kaybÄ± olabilir** (Tek bir alan deÄŸiÅŸse bile tÃ¼m dokÃ¼man gÃ¼ncellenir).  

---

## **ğŸ“Œ Reference (Referans ile Ä°liÅŸkilendirme)**
**Bu yÃ¶ntemde, iliÅŸkili veriler farklÄ± koleksiyonlarda saklanÄ±r ve ObjectId ile birbirine baÄŸlanÄ±r.**  
Ã–rneÄŸin, bir **User ve Orders (SipariÅŸler) koleksiyonu** ÅŸu ÅŸekilde olabilir:

### **User Koleksiyonu**
```json
{
  "_id": "603d9c69f1a5c34b8c4f9e4a",
  "name": "Orhan GÃ¼zel",
  "email": "orhan@gmail.com",
  "orders": ["605c72d2f3a9f854d8d546b9", "605c72d2f3a9f854d8d546ba"]
}
```

### **Orders Koleksiyonu**
```json
{
  "_id": "605c72d2f3a9f854d8d546b9",
  "userId": "603d9c69f1a5c34b8c4f9e4a",
  "total": 125.50,
  "items": [
    {"name": "Laptop", "price": 1000},
    {"name": "Mouse", "price": 25.50}
  ]
}
```

### **âœ” AvantajlarÄ±:**
- **Daha esnek bir yapÄ± sunar** (Ã–rneÄŸin bir kullanÄ±cÄ±nÄ±n 1000 sipariÅŸi olabilir ve bu kullanÄ±cÄ±yÄ± gÃ¼ncellemek kolaydÄ±r).  
- **GÃ¼ncelleme ve silme iÅŸlemleri daha performanslÄ±dÄ±r**.  
- **Ä°liÅŸkili koleksiyonlarÄ± istediÄŸimiz gibi geniÅŸletebiliriz**.  

### **âŒ DezavantajlarÄ±:**
- **Veri getirmek iÃ§in birden fazla sorgu (lookup) gerekebilir**.  
- **Daha karmaÅŸÄ±k sorgular gerektirebilir**.  
- **BazÄ± senaryolarda performans kaybÄ± yaÅŸanabilir**.  

---

## **ğŸ“Œ Embedded Documents vs. References**
| YÃ¶ntem | AvantajlarÄ± | DezavantajlarÄ± |
|--------|------------|---------------|
| **Embedded Documents** | Tek sorguyla tÃ¼m verilere ulaÅŸÄ±lÄ±r, daha hÄ±zlÄ± okuma iÅŸlemleri saÄŸlar | Veri tekrarÄ± olabilir, bÃ¼yÃ¼k veri iÃ§erdiÄŸinde esneklik kaybÄ± olabilir |
| **References (ObjectId ile BaÄŸlama)** | Daha az veri tekrarÄ± olur, esnek yapÄ± saÄŸlar | Ek sorgular gerektirir, performans kaybÄ± yaÅŸanabilir |

---

## **ğŸ“Œ MongoDB'de Veri Ä°liÅŸkileri KullanÄ±mÄ±**
### **1ï¸âƒ£ Embedded Documents KullanÄ±mÄ±**
```javascript
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  address: {
    street: String,
    city: String,
    zip: String
  }
});

export const User = mongoose.model("User", userSchema);
```

---

### **2ï¸âƒ£ Reference KullanÄ±mÄ± (ObjectId ile BaÄŸlantÄ±)**
```javascript
import mongoose from "mongoose";

// User Model
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  orders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }]
});

export const User = mongoose.model("User", userSchema);

// Order Model
const orderSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  total: Number,
  items: [{ name: String, price: Number }]
});

export const Order = mongoose.model("Order", orderSchema);
```

---

### **ğŸ“Œ SonuÃ§: Hangi YÃ¶ntem Ne Zaman KullanÄ±lmalÄ±?**
- **EÄŸer iliÅŸkili veriler her zaman birlikte kullanÄ±lacaksa** â†’ **Embedded Documents** tercih edilir.  
- **EÄŸer iliÅŸkili veriler Ã§ok bÃ¼yÃ¼kse ve ayrÄ± sorgulanacaksa** â†’ **References (ObjectId ile BaÄŸlama)** tercih edilir.  
- **EÄŸer Ã§ok fazla deÄŸiÅŸiklik yapÄ±lan bÃ¼yÃ¼k veri setleri varsa** â†’ **References daha verimlidir.**  
- **Sorgu performansÄ±nÄ± artÄ±rmak istiyorsan** â†’ **DoÄŸru indeklemeyle (indexing) Reference yapÄ±sÄ±nÄ± kullanabilirsin.**  

---

### **ğŸ”¥ Ã–zet**
âœ… **MongoDB'de iliÅŸkiler iki ÅŸekilde yÃ¶netilir:** **Embedded Documents ve References**.  
âœ… **Embedded Documents** iliÅŸkili verileri tek bir dokÃ¼manda saklar ve **hÄ±zlÄ± okuma iÅŸlemleri** iÃ§in idealdir.  
âœ… **References (ObjectId ile BaÄŸlama)** yÃ¶ntemi **bÃ¼yÃ¼k veri setleri ve esnek veri yapÄ±larÄ±** iÃ§in uygundur.  
âœ… **Mongoose'da `populate()` kullanarak referanslÄ± dokÃ¼manlarÄ± kolayca Ã§ekebilirsin**.  
âœ… **DoÄŸru yÃ¶ntemi seÃ§mek iÃ§in, verinin kullanÄ±m ÅŸekline gÃ¶re karar vermelisin!**  

ğŸš€ **Sonraki adÄ±mda `populate()` ile MongoDB iliÅŸkilerini nasÄ±l kullanacaÄŸÄ±mÄ±zÄ± gÃ¶receÄŸiz!** ğŸš€