### **2. Wie viele `Arten` von `Beziehungen` gibt es in MongoDB?**  
(**MongoDB'de KaÃ§ TÃ¼r Ä°liÅŸki VardÄ±r?**)

MongoDB, iliÅŸkisel (SQL) veritabanlarÄ±ndan farklÄ± olarak **ÅŸemasÄ± esnek** olan **dokÃ¼man tabanlÄ±** bir veritabanÄ±dÄ±r. Ancak **veriler arasÄ±ndaki iliÅŸkileri yÃ¶netmek iÃ§in** yine de bazÄ± iliÅŸki tÃ¼rleri kullanÄ±labilir.  

MongoDBâ€™de **Ã¼Ã§ ana veri iliÅŸkisi tÃ¼rÃ¼** vardÄ±r:

### **1ï¸âƒ£  One-to-One (Bire Bir Ä°liÅŸki)**
### **2ï¸âƒ£  One-to-Many (Bire Ã‡ok Ä°liÅŸki)**
### **3ï¸âƒ£  Many-to-Many (Ã‡oktan Ã‡oÄŸa Ä°liÅŸki)**

BunlarÄ± **Embedded (Ä°Ã§ Ä°Ã§e GeÃ§miÅŸ DokÃ¼man)** veya **References (ObjectId ile BaÄŸlantÄ±)** kullanarak yÃ¶netebiliriz.

---

## **ğŸ“Œ 1ï¸âƒ£ One-to-One (Bire Bir Ä°liÅŸki)**
Bir dokÃ¼manÄ±n **yalnÄ±zca bir diÄŸer dokÃ¼man ile iliÅŸkili olduÄŸu** durumdur.  
ğŸ“Œ **Ã–rnek:**  
- Bir kullanÄ±cÄ±nÄ±n yalnÄ±zca **bir adresi** olabilir.  
- Bir Ã§alÄ±ÅŸanÄ±n yalnÄ±zca **bir kimlik kartÄ±** olabilir.

### **â¡ YÃ¶ntem 1: Embedded Documents KullanÄ±mÄ±**
EÄŸer iliÅŸkili veriler **her zaman birlikte sorgulanacaksa**, iÃ§ iÃ§e geÃ§miÅŸ (embedded) dokÃ¼man yÃ¶ntemi kullanÄ±labilir.

```javascript
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  address: {
    street: String,
    city: String,
    zip: String
  }
});

export const User = mongoose.model("User", userSchema);
```
ğŸ”¹ **AvantajÄ±:** Daha hÄ±zlÄ± eriÅŸim saÄŸlar.  
ğŸ”¹ **DezavantajÄ±:** GÃ¼ncellemeler tÃ¼m dokÃ¼manÄ± deÄŸiÅŸtirebilir.

---

### **â¡ YÃ¶ntem 2: References (ObjectId ile BaÄŸlantÄ±) KullanÄ±mÄ±**
EÄŸer **iliÅŸkili veri bÃ¼yÃ¼yorsa veya ayrÄ± ayrÄ± sorgulanacaksa**, ObjectId kullanarak iki koleksiyonu baÄŸlayabiliriz.

```javascript
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  address: { type: mongoose.Schema.Types.ObjectId, ref: "Address" }
});

const addressSchema = new mongoose.Schema({
  street: String,
  city: String,
  zip: String
});

export const User = mongoose.model("User", userSchema);
export const Address = mongoose.model("Address", addressSchema);
```

ğŸ“Œ **Veriyi Getirme (populate ile)**  
```javascript
const user = await User.find().populate("address");
console.log(user);
```

âœ… **KullanÄ±m AlanÄ±:** BÃ¼yÃ¼k veri setlerinde ve ayrÄ± sorgulamak istediÄŸimizde.

---

## **ğŸ“Œ 2ï¸âƒ£ One-to-Many (Bire Ã‡ok Ä°liÅŸki)**
Bir dokÃ¼manÄ±n **birden fazla dokÃ¼man ile iliÅŸkili olduÄŸu** durumdur.  
ğŸ“Œ **Ã–rnek:**  
- Bir yazarÄ±n **birden fazla blog yazÄ±sÄ±** olabilir.  
- Bir kullanÄ±cÄ±nÄ±n **birden fazla sipariÅŸi** olabilir.  

### **â¡ YÃ¶ntem 1: Embedded Documents KullanÄ±mÄ±**
EÄŸer **baÄŸlÄ± veriler az ve genellikle aynÄ± anda sorgulanacaksa**, iliÅŸkili verileri iÃ§ iÃ§e koyabiliriz.

```javascript
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  orders: [
    {
      total: Number,
      items: [{ name: String, price: Number }]
    }
  ]
});

export const User = mongoose.model("User", userSchema);
```

ğŸ”¹ **AvantajÄ±:** Tek sorguda tÃ¼m verilere ulaÅŸÄ±lÄ±r.  
ğŸ”¹ **DezavantajÄ±:** SipariÅŸler arttÄ±kÃ§a dokÃ¼man bÃ¼yÃ¼yebilir.

---

### **â¡ YÃ¶ntem 2: References (ObjectId ile BaÄŸlantÄ±) KullanÄ±mÄ±**
EÄŸer **iliÅŸkili veri bÃ¼yÃ¼yorsa ve ayrÄ± koleksiyonlarda saklanacaksa**, ObjectId ile baÄŸlantÄ± kurabiliriz.

```javascript
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  orders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }]
});

const orderSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  total: Number,
  items: [{ name: String, price: Number }]
});

export const User = mongoose.model("User", userSchema);
export const Order = mongoose.model("Order", orderSchema);
```

ğŸ“Œ **Veriyi Getirme (populate ile)**  
```javascript
const user = await User.find().populate("orders");
console.log(user);
```

âœ… **KullanÄ±m AlanÄ±:** BÃ¼yÃ¼k veri setlerinde ve performans iÃ§in.

---

## **ğŸ“Œ 3ï¸âƒ£ Many-to-Many (Ã‡oktan Ã‡oÄŸa Ä°liÅŸki)**
Bir dokÃ¼manÄ±n **birden fazla dokÃ¼man ile ve diÄŸer dokÃ¼manlarÄ±n da birden fazla dokÃ¼manla iliÅŸkili olduÄŸu** durumdur.  
ğŸ“Œ **Ã–rnek:**  
- Bir Ã¶ÄŸrencinin **birden fazla kursa** kayÄ±tlÄ± olmasÄ± ve bir kursun **birden fazla Ã¶ÄŸrencisi** olmasÄ±.  
- Bir Ã¼rÃ¼nÃ¼n **birden fazla kategoride** yer almasÄ± ve bir kategorinin **birden fazla Ã¼rÃ¼nÃ¼** iÃ§ermesi.

### **â¡ References (ObjectId ile BaÄŸlantÄ±) KullanÄ±mÄ±**
Many-to-Many iliÅŸkileri **her zaman ayrÄ± koleksiyonlarda saklanÄ±r ve `ObjectId` ile baÄŸlanÄ±r**.

```javascript
const studentSchema = new mongoose.Schema({
  name: String,
  courses: [{ type: mongoose.Schema.Types.ObjectId, ref: "Course" }]
});

const courseSchema = new mongoose.Schema({
  title: String,
  students: [{ type: mongoose.Schema.Types.ObjectId, ref: "Student" }]
});

export const Student = mongoose.model("Student", studentSchema);
export const Course = mongoose.model("Course", courseSchema);
```

ğŸ“Œ **Veriyi Getirme (populate ile)**  
```javascript
const student = await Student.find().populate("courses");
console.log(student);
```

âœ… **KullanÄ±m AlanÄ±:** Ã‡apraz iliÅŸkilerin olduÄŸu durumlar (Ã–ÄŸrenci-Kurs, Film-Actor vb.).

---

## **ğŸ“Œ Ã–zet: MongoDBâ€™de Veri Ä°liÅŸkileri**
| **Ä°liÅŸki TÃ¼rÃ¼** | **AÃ§Ä±klama** | **Ã–rnek KullanÄ±m** | **Ã–nerilen YÃ¶ntem** |
|----------------|-------------|-----------------|-----------------|
| **One-to-One** | Bir dokÃ¼man yalnÄ±zca bir dokÃ¼manla baÄŸlantÄ±lÄ±dÄ±r. | KullanÄ±cÄ± - Adres | **Embedded** (kÃ¼Ã§Ã¼k veri) / **Reference** (bÃ¼yÃ¼k veri) |
| **One-to-Many** | Bir dokÃ¼manÄ±n birden fazla iliÅŸkili dokÃ¼manÄ± vardÄ±r. | KullanÄ±cÄ± - SipariÅŸler | **Embedded** (az veri) / **Reference** (bÃ¼yÃ¼k veri) |
| **Many-to-Many** | Bir dokÃ¼man birden fazla dokÃ¼manla, diÄŸer dokÃ¼man da birden fazla dokÃ¼manla iliÅŸkilidir. | Ã–ÄŸrenci - Kurslar | **Reference (ObjectId)** |

---

## **ğŸ”¥ MongoDB'de Ä°liÅŸki SeÃ§imi NasÄ±l YapÄ±lÄ±r?**
- **KÃ¼Ã§Ã¼k veri setleri** ve **her zaman birlikte sorgulanacak iliÅŸkiler** iÃ§in â†’ **Embedded Documents**  
- **BÃ¼yÃ¼k veri setleri**, **baÄŸÄ±msÄ±z sorgular gerektiren iliÅŸkiler** iÃ§in â†’ **Reference (ObjectId ile BaÄŸlantÄ±)**  
- **Esneklik ve sorgu performansÄ±** iÃ§in â†’ **Reference kullanarak `populate()` ile verileri Ã§aÄŸÄ±rmak**  

ğŸš€ **Sonraki adÄ±m:** **MongoDB'de `populate()` kullanarak iliÅŸkili verileri nasÄ±l Ã§aÄŸÄ±rÄ±rÄ±z?** ğŸš€